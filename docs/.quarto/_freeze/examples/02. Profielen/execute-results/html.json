{
  "hash": "8ff7e4b53ac0c3bf5e91060a3bd02e15",
  "result": {
    "engine": "jupyter",
    "markdown": "<h1>Profielen</h1>\n\nAllereerst importeren we de nieuwe Pydra vanuit hkvpy\n\n::: {#5cc2f2b1 .cell execution_count=1}\n``` {.python .cell-code}\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nfrom copy import deepcopy\nimport pydra_core as pydra\n```\n:::\n\n\nIn deze versie van Pydra is het profiel losgekoppeld van de belasting en statistiek. Hierdoor is het mogelijk om alleen een profiel te maken en overslag en oploop te berekenen zonder het koppelen van belasting en statistiek.\n\nEr zijn drie manieren om een profiel aan te maken:\n<lu>\n    <li>Handmatig</li>\n    <li>Import een .prfl</li>\n    <li>Import een schematisatie vanuit de GEBU-GEKB tool</li>\n</lu>\n\n<h3>Profiel</h3>\n\nHet <i>Profile</i> is de basis voor elk profiel. Als argument moet een naam voor het profiel worden opgegeven.\n\n::: {#81781d6b .cell execution_count=2}\n``` {.python .cell-code}\nprofiel = pydra.Profile(\"test_profiel\")\n```\n:::\n\n\n<h3>Handmatig</h3>\n\nHet <i>Profile</i> object heeft allemaal functies (startend met <i>set_...()</i>) om het profiel te veranderen. Er zijn globaal drie dingen die aan een profiel kan veranderen:\n<lu>\n    <li>Dijkgeometrie</li>\n    <li>Voorland</li>\n    <li>Voorliggende keringen</li>\n</lu>\n\n<b>Dijkgeometrie</b><br>\nVoordat een profiel werkt moet een kruinhoogte, dijkorientatie en geometrie worden gedefinieerd. Een voorbeeld is gegeven in de onderstaande code.\n\n::: {#0aee0e33 .cell execution_count=3}\n``` {.python .cell-code}\n# Kruinhoogte\nprofiel.set_dike_crest_level(8.0)\n\n# Dijkorientatie\nprofiel.set_dike_orientation(90)\n\n# Dijkgeometrie\nprofiel.set_dike_geometry([-6, 30], [-2, 10], [1.0, 1.0])\n```\n:::\n\n\nDe <i>set_dike_geometry(x, y, r)</i> heeft drie argumenten, de x-coordinaten, de y-coordinaten, en de ruwheden. Eventueel kunnen de ruwheden worden weggelaten, er wordt dan standaard met een ruwheid van 1.0 gerekend.\n\n::: {#c9c24238 .cell execution_count=4}\n``` {.python .cell-code}\n# Dijkgeometrie\nprofiel.set_dike_geometry([-6, 30], [-2, 10])\n```\n:::\n\n\nMet de <i>draw_profile()</i> functie kan een plot van de doorsnede worden weergegeven.\n\n::: {#35e903a7 .cell execution_count=5}\n``` {.python .cell-code}\nprofiel.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-6-output-1.png){width=662 height=450}\n:::\n:::\n\n\n<b>Voorland</b><br>\nEen voorland kan worden toegevoegd met <i>set_foreland_geometry(x, y)</i> en heeft twee argumenten, de x-coordinaten en de y-coordinaten. Een profiel wordt altijd zo geschematiseerd dat de dijkteen op x = 0 ligt. Het voorland ligt altijd in het negatieve x-domein en de dijkgeometrie in het positieve x-domein.\n\n::: {#a45dc1c9 .cell execution_count=6}\n``` {.python .cell-code}\n# Voorland\nprofiel.set_foreland_geometry([-100, -70], [-3, -2])\n```\n:::\n\n\nMerk op dat ondanks dat we hierboven het voorland hebben gedefinieerd lopend van -100 tot -70, pydra automatisch zorgt dat het voorland aansluit op de teen van de dijk (x = 0). Het voorland wordt dus gecorrigeerd zodat deze loopt van -30 naar 0. Zie de figuur hieronder.\n\n::: {#a6768ddf .cell execution_count=7}\n``` {.python .cell-code}\nprofiel.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-8-output-1.png){width=662 height=450}\n:::\n:::\n\n\n<b>Voorliggende kering</b><br>\nEen voorliggende kering, zoals een golfbreker kan worden toegevoegd met de functie <i>set_breakwater(breakwater, hoogte)</i>. De functie heeft twee argumenten, het type Breakwater (gedefinieerd via Enum) en de hoogte van de Breakwater.\n\n::: {#547a41f5 .cell execution_count=8}\n``` {.python .cell-code}\n# Importeer de Breakwater Enum\nfrom pydra_core import Breakwater\n\n\"\"\"\nKeuzes:\nBreakwater.NO_BREAKWATER\nBreakwater.CAISSON\nBreakwater.VERTICAL_WALL\nBreakwater.RUBBLE_MOUND\n\"\"\"\n\n# Hier wordt een RubbleMound als Breakwater ingesteld met een hoogte van NAP+3,0m\nprofiel.set_breakwater(Breakwater.RUBBLE_MOUND, 3.0)\n```\n:::\n\n\nDit geeft de volgende doorsnede.\n\n::: {#16d55f50 .cell execution_count=9}\n``` {.python .cell-code}\nprofiel.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-10-output-1.png){width=668 height=450}\n:::\n:::\n\n\n<b>Verwijderen van een voorliggende kering/voorland</b><br>\nJe kan een voorliggende kering/voorland verwijderen met de functies <i>remove_breakwater()</i> en <i>remove_foreland()</i>.\n\n::: {#5957f33b .cell execution_count=10}\n``` {.python .cell-code}\n# Verwijder voorland\nprofiel.remove_breakwater()\n\n# Verwijder voorliggende kering\nprofiel.remove_foreland()\n```\n:::\n\n\nNu zonder voorland\n\n::: {#2d0d2d0c .cell execution_count=11}\n``` {.python .cell-code}\nprofiel.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-12-output-1.png){width=662 height=450}\n:::\n:::\n\n\n<h3>Importeer een .prfl</h3>\n\nIn plaats van handmatig een profiel te definiëren is het ook mogelijk om een .prfl te importeren. Hiervoor kan de classmethod <i>Profile.from_prfl(prfl_path)</i> worden gebruikt. Door het optionele argument <i>name</i> te definiëren kan een naam aan het profielbestand worden gegeven.\n\n::: {#d8d36801 .cell execution_count=12}\n``` {.python .cell-code}\nPRFL_PATH = \"data/profielformaat.prfl\"\n\nprofiel_prfl = pydra.Profile.from_prfl(PRFL_PATH, profile_name= \"Profiel vanuit een prfl\")\n```\n:::\n\n\nDat geeft de volgende doorsnede:\n\n::: {#016bde6d .cell execution_count=13}\n``` {.python .cell-code}\nprofiel_prfl.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-14-output-1.png){width=651 height=450}\n:::\n:::\n\n\n<h3>Import een schematisatie vanuit de GEBU-GEKB tool</h3>\n\nHet is ook mogelijk om een profiel te importeren uit de <i>1.sql</i> van de GEBU-GEKB plugin voor Hydra-Ring. Hiervoor kan de classmethod Profile.from_gebugekb_tool(sql_path) worden gebruikt. De opzet van de classmethod/functie is hetzelfde als voor het importeren van een .prfl.\n\n::: {#7f130318 .cell execution_count=14}\n``` {.python .cell-code}\nSQL_PATH = \"data/1.sql\"\n\nprofiel_sql = pydra.Profile.from_gebugekb_tool(SQL_PATH, profile_name=\"Profiel vanuit een 1.sql\")\n```\n:::\n\n\nDat geeft de volgende doorsnede:\n\n::: {#4b43429a .cell execution_count=15}\n``` {.python .cell-code}\nprofiel_sql.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-16-output-1.png){width=662 height=450}\n:::\n:::\n\n\n<h3>Exporteer het Profile object naar een .prfl</h3>\n\nHet is mogelijk om een <i>Profile</i> object te exporteren naar een .prfl. Handig als je bijvoorbeeld schematisaties uit de GEBUGEKB-tool wilt omzetten naar een .prfl, of veel profielen wilt genereren met een loop.\n\nJe kan een profiel exporteren met de functie <i>to_prfl(export_path)</i>. Het is met optionele argumenten mogelijk om een ID (toevoegen van argument <i>id = \"voorbeeld_id\"</i>) of een memo (toevoegen van argument <i>memo = \"een memo\"</i>) toe te voegen. Hieronder exporteren we de profielen die we eerder hebben geschematiseerd naar de RO1099 map.\n\n::: {#2aba7262 .cell execution_count=16}\n``` {.python .cell-code}\n# Zonder ID of memo\nprofiel.to_prfl(\"data/export_profiel_1.prfl\")\n\n# Met memo\nprofiel_prfl.to_prfl(\"data/export_profiel_2.prfl\", memo = \"mooi profiel\")\n\n# Met ID en memo\nprofiel_sql.to_prfl(\"data/export_profiel_3.prfl\", id = \"test\", memo = \"profiel uit de gebu-gekb tool\")\n```\n:::\n\n\n<h3>Golftransitie over voorland</h3>\n\nHet is mogelijk om met het Profile object de golftransitie over het voorland te bepalen. In deze demonstratie bepalen we het effect van het voorland voor het volgende profiel:\n\n::: {#0b5f08cb .cell execution_count=17}\n``` {.python .cell-code}\nprofiel_prfl.draw_profile()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-18-output-1.png){width=651 height=450}\n:::\n:::\n\n\nDe functie <i>transform_wave_conditions(h, hs, tspec, wdir)</i> kan gebruikt worden om de getransformeerde golfcondities te bepalen. Met het optionele argument <i>tp_tspec</i> wordt de spectrale golfperiode omgerekend naar de piekperiode (welke wordt gebruikt in de DaF module) en vervolgens weer teruggerekend naar de spectrale golfperiode. Standaard is <i>tp_tspec</i> gelijk aan 1.1.\n\n::: {#01641162 .cell execution_count=18}\n``` {.python .cell-code}\n# HR\nh = 6.0\nhs = 2.0\ntspec = 5.0\nwdir = 84\n\n# De invoer kunnen floats of ints zijn\n_h, _hs, _tspec, _wdir = profiel_prfl.transform_wave_conditions(h, hs, tspec, wdir)\n\nprint(\"h\", h, \"->\", _h)\nprint(\"hs\", hs, \"->\", _hs)\nprint(\"tspec\", tspec, \"->\", _tspec)\nprint(\"wdir\", wdir, \"->\", _wdir)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh 6.0 -> 6.0\nhs 2.0 -> 1.2000734264388144\ntspec 5.0 -> 5.0\nwdir 84 -> 81.43355290660857\n```\n:::\n:::\n\n\nJe kan ook arrays gebruiken. Merk op dat we hieronder alleen de waterstand <i>h</i> en significante golfhoogte <i>Hs</i> als arrays hebben gedefinieerd. Wanneer je een deel van de input parameters (h, hs, tspec, wdir) als array definieerd en een deel niet, vult pydra deze automatisch aan. In het onderstaande geval worden alle combinaties met een tspec van 5.0 gerekend en een wdir van 84.\n\n::: {#30076276 .cell execution_count=19}\n``` {.python .cell-code}\n# HR\nh = [3.0, 4.0, 5.0, 6.0]\nhs = [2.0, 2.2, 2.4, 2.6]\ntspec = 5.0\nwdir = 84\n\n# De invoer kunnen floats of ints zijn\n_h, _hs, _tspec, _wdir = profiel_prfl.transform_wave_conditions(h, hs, tspec, wdir)\n\nprint(\"h\", h, \"->\", _h)\nprint(\"hs\", hs, \"->\", _hs)\nprint(\"tspec\", tspec, \"->\", _tspec)\nprint(\"wdir\", wdir, \"->\", _wdir)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nh [3.0, 4.0, 5.0, 6.0] -> [3. 4. 5. 6.]\nhs [2.0, 2.2, 2.4, 2.6] -> [0.80432189 1.08827125 1.32752829 1.52129885]\ntspec 5.0 -> [5. 5. 5. 5.]\nwdir 84 -> [78.72302003 79.97242374 80.81683168 81.43355291]\n```\n:::\n:::\n\n\n<h3>Golfoverslag en overloop</h3>\n\nMet een <i>Profile</i> object kan golfoverslag en overloop bepalen met de functie <i>calculate_overtopping(h, hs, tspec, wdir)</i>. Net zoals bij de golftransformatie over het voorland kan de invoer bestaan uit floats, ints, arrays of een combinatie. Hieronder wordt deze functie gedemonstreerd voor dezelfde doorsnede waarbij de golftransformatie over het voorland is gedemonstreerd (zie doorsnede hierboven).\n\n::: {#8c007dd8 .cell execution_count=20}\n``` {.python .cell-code}\n# HR\nh = 4.0\nhs = 2.0\ntspec = 5.0\nwdir = 84\n\n# Overslag\nqov = profiel_prfl.calculate_overtopping(h, hs, tspec, wdir)\nprint(\"qov =\", qov, \"m3/m/s\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nqov = 0.01671347888602151 m3/m/s\n```\n:::\n:::\n\n\nDoor bijvoorbeeld de waterstand als array te definieren kan heel eenvoudig het overslagdebiet geplot worden tegen de waterstand.\n\n::: {#57d42811 .cell execution_count=21}\n``` {.python .cell-code}\n# Bepaal een range aan waterstanden\nh = np.arange(0.0, 6.0, 0.1)\nhs = 1.0\ntspec = 4.0\nwdir = 84\n\n# Overslag\nqov = profiel_prfl.calculate_overtopping(h, hs, tspec, wdir)\n\n# Plot\nplt.figure()\nplt.plot(h, qov, label = \"Overslag\")\nplt.axvline(5.0, ls = \":\", label = \"Kruinhoogte\")\nplt.title(\"Overslagdebiet voor verschillende waterstanden\")\nplt.xlabel(\"Waterstand [NAP+m]\")\nplt.xlim(0, None)\nplt.ylabel(\"Overslagdebiet [m3/m/s]\")\nplt.ylim(0, None)\nplt.legend(loc = \"best\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-22-output-1.png){width=597 height=449}\n:::\n:::\n\n\n<h3>Oploophoogte</h3>\n\nHetzelfde is ook mogelijk voor de 2% oploophoogte. Hiervoor kan de functie <i>calculate_runup(h, hs, tspec, wdir)</i> worden gebruikt.\n\n::: {#709edbc9 .cell execution_count=22}\n``` {.python .cell-code}\n# HR\nh = 4.0\nhs = 2.0\ntspec = 5.0\nwdir = 84\n\n# Oploop\nz2p = profiel_prfl.calculate_runup(h, hs, tspec, wdir)\nprint(\"z2% =\", z2p, \"NAP+m\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nz2% = 6.380539983822968 NAP+m\n```\n:::\n:::\n\n\nVoorbeeld voor meerdere golfhoogtes bij eenzelfde waterstand, spectrale golfperiode en hoek van golfinval.\n\n::: {#b44dfd82 .cell execution_count=23}\n``` {.python .cell-code}\n# Bepaal een range aan golfhoogtes\nh = 4.0\nhs = np.arange(0.0, 3.0, 0.1)\ntspec = 5.0\nwdir = 84\n\n# Oploop\nz2p = profiel_prfl.calculate_runup(h, hs, tspec, wdir)\n\n# Plot\nplt.figure()\nplt.plot(hs, z2p, label = \"Oploophoogte\")\nplt.title(\"Oploophoogte voor verschillende golfhoogtes\")\nplt.xlabel(\"Significante golfhoogte [m]\")\nplt.xlim(0, None)\nplt.ylabel(\"Oploophoogte [NAP+m]\")\nplt.ylim(4, None)\nplt.legend(loc = \"best\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-24-output-1.png){width=592 height=449}\n:::\n:::\n\n\n<h3>Kruinhoogte bepalen</h3>\n\nAls laatste is het mogelijk om de kruinhoogte te bepalen gegeven een overslagdebiet. Dit kan met de functie <i>calculate_crest_level(q_critical, h, hs, tspec, wdir)</i>.\n\n::: {#6430e6a0 .cell execution_count=24}\n``` {.python .cell-code}\n# HR\nq = 0.01\nh = 4.0\nhs = 2.0\ntspec = 5.0\nwdir = 84\n\n# Kruinhoogte voor 10 l/m/s\nhbn = profiel_prfl.calculate_crest_level(q, h, hs, tspec, wdir)\nprint(\"Benodigde kruinhoogte =\", hbn, \"NAP+m\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nBenodigde kruinhoogte = 5.14724745829701 NAP+m\n```\n:::\n:::\n\n\nMet de overslag functie kunnen we makkelijk controleren of deze kruinhoogte klopt\n\n::: {#6c7f96ea .cell execution_count=25}\n``` {.python .cell-code}\n# HR\nq = 0.01\nh = 4.0\nhs = 2.0\ntspec = 5.0\nwdir = 84\n\n# Check\ntest_prfl = deepcopy(profiel_prfl)\ntest_prfl.set_dike_crest_level(hbn)\nqov = test_prfl.calculate_overtopping(h, hs, tspec, wdir)\n\nprint(\"Check met aangepaste kruinhoogte:\", round(qov, 6), \"m3/m/s\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCheck met aangepaste kruinhoogte: 0.01 m3/m/s\n```\n:::\n:::\n\n\nAls we dan toch bezig zijn, kunnen we een mooi grafiekje voor de kruinhoogte bepaling niet achterwege laten...\n\n::: {#efddda1d .cell execution_count=26}\n``` {.python .cell-code}\n# Bepaal een range aan overslagdebieten\nq = np.arange(0.001, 0.1, 0.001)\nh = 4.0\nhs = 2.0\ntspec = 5.0\nwdir = 84\n\n# Oploop\nhbn = profiel_prfl.calculate_crest_level(q, h, hs, tspec, wdir)\n\n# Plot\nplt.figure()\nplt.plot(q, hbn, label = \"Kruinhoogte\")\nplt.title(\"Kruinhoogte voor verschillende overslagdebieten\")\nplt.xlabel(\"Overslagdebiet [m3/m/s]\")\nplt.xlim(0, None)\nplt.ylabel(\"Kruinhoogte [NAP+m]\")\nplt.ylim(0, None)\nplt.legend(loc = \"best\")\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](02. Profielen_files/figure-html/cell-27-output-1.png){width=576 height=449}\n:::\n:::\n\n\n",
    "supporting": [
      "02. Profielen_files"
    ],
    "filters": [],
    "includes": {}
  }
}